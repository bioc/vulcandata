{
    "collab_server" : "",
    "contents" : "#' Function to import BAM files\n#'\n#' This function coalesces and annotates a set of BAM files into peak-centered\n#' data\n#'\n#' @param sheetfile path to a csv annotation file containing sample information\n#' and BAM location\n#' @param intervals size of the peaks. If NULL (default) it is inferred from\n#' the average fragment length observed in the dataset\n#'\n#' @return a list\n#'\n#' @examples\n#' require(vulcandata)\n#' vfile<-\"deleteme.csv\"\n#' vulcansheet(vfile)\n#' vobj<-vulcan.import(vfile)\n#' unlink(vfile)\n#'\n#' @export\nvulcan.import<-function(sheetfile,intervals=NULL){\n    # Check the dataset\n    sheet<-read.csv(sheetfile,as.is=TRUE)\n\n    # Generate a DiffBind object\n    dbobj<-dba(sampleSheet=sheetfile)\n    message(\"Sheet loaded. You have \",nrow(sheet), \" samples and \",\n            length(unique(sheet$Condition)),\" conditions\")\n\n    # Select the interval size automatically (if not provided by the user)\n    if(is.null(intervals)){\n        # List of bam files\n        bam.files <- sheet[,\"bamReads\"]\n        intervals<-average_fragment_length(bam.files,plot=FALSE)*2\n        message(\"Peak size automatically detected as \",intervals,\"nt\")\n    }\n\n    # Count reads in binding sites intervals\n    dbcounts<-dba.count(dbobj,summits=intervals)\n\n    # Extract counts from the dbacount object\n    listcounts<-dbcounts$peaks\n    names(listcounts)<-dbcounts$samples[,1]\n\n    # Prepare RPKM matrix\n    first<-listcounts[[1]]\n    rawmat<-matrix(NA, nrow = nrow(first), ncol = length(listcounts)+3)\n    colnames(rawmat)<-c(\"Chr\",\"Start\",\"End\",names(listcounts))\n    rownames(rawmat)<-1:nrow(rawmat)\n    rawmat<-as.data.frame(rawmat)\n    rawmat[,1]<-as.character(first[,1])\n    rawmat[,2]<-as.integer(first[,2])\n    rawmat[,3]<-as.integer(first[,3])\n    for(i in 1:length(listcounts)){\n        rawmat[,names(listcounts)[i]]<-as.numeric(listcounts[[i]]$RPKM)\n    }\n    peakrpkms<-rawmat\n    rm(rawmat)\n\n    # Prepare Count matrix\n    first<-listcounts[[1]]\n    rawmat<-matrix(NA, nrow = nrow(first), ncol = length(listcounts)+3)\n    colnames(rawmat)<-c(\"Chr\",\"Start\",\"End\",names(listcounts))\n    rownames(rawmat)<-1:nrow(rawmat)\n    rawmat<-as.data.frame(rawmat)\n    rawmat[,1]<-as.character(first[,1])\n    rawmat[,2]<-as.integer(first[,2])\n    rawmat[,3]<-as.integer(first[,3])\n    for(i in 1:length(listcounts)){\n        rawmat[,names(listcounts)[i]]<-as.integer(listcounts[[i]]$Reads)\n    }\n    peakcounts<-rawmat\n    rm(rawmat)\n\n\n    # Create an annotation structure\n    samples<-list()\n    conditions<-unique(sheet$Condition)\n    for(cond in conditions){\n        heresamples<-sheet$SampleID[sheet$Condition==cond]\n        samples[[cond]]<-heresamples\n    }\n\n    # Return output\n    vobj<-list(peakcounts=peakcounts,samples=samples,peakrpkms=peakrpkms)\n    return(vobj)\n}\n\n#' Function to annotate peaks for VULCAN analysis\n#'\n#' This function coalesces and annotates a set of BAM files into peak-centered\n#' data\n#'\n#' @param vobj A list of peakcounts, samples and peakrpkms (i.e. the output of\n#' the funcion vulcan.import)\n#' @param method Method to deal with multiple peaks found within gene promoter\n#' boundaries.\n#' One of \"closest\",\"strongest\",\"sum\"(default),\"topvar\",\"farthest\",\"lowvar\"\n#' @param lborder Boundary for peak annotation (in nucleotides) upstream of\n#' the Transcription starting site (default: -10000)\n#' @param lborder Boundary for peak annotation (in nucleotides) downstream of\n#' the Transcription starting site (default: 10000)\n#' @return a list\n#' @examples\n#' require(vulcandata)\n#' vfile<-\"deleteme.csv\"\n#' vulcansheet(vfile)\n#' vobj<-vulcan.import(vfile)\n#' unlink(vfile)\n#' vobj<-vulcan.annotate(vobj,lborder=-10000,rborder=10000,method=\"sum\")\n#' @export\nvulcan.annotate<-function(vobj,lborder=-10000,rborder=10000,\n                          method=c(\"closest\",\"strongest\",\"sum\",\"topvar\",\n                                   \"farthest\",\"lowvar\")\n){\n    # Annotate (hg19)\n    annotation<-toGRanges(TxDb.Hsapiens.UCSC.hg19.knownGene, feature=\"gene\")\n\n    ##### PROCESS RAW COUNTS\n    gr<-GRanges(vobj$peakcounts)\n    anno<-annotatePeakInBatch(gr,AnnotationData=annotation,output=\"overlapping\",\n                              FeatureLocForDistance=\"TSS\",\n                              bindingRegion=c(lborder,rborder))\n\n    # Convert to a more handy data frame\n    dfanno<-anno\n    names(dfanno)<-1:length(dfanno)\n    dfanno<-as.data.frame(dfanno)\n\n    # Prepare the output table\n    allsamples<-unique(unlist(vobj$samples))\n    genes<-unique(dfanno$feature)\n    peakspergene<-table(dfanno$feature)\n    rawcounts<-matrix(NA,nrow=length(genes),ncol=length(allsamples))\n    colnames(rawcounts)<-allsamples\n    rownames(rawcounts)<-genes\n\n    # All methods: if a gene has a single peak, you select that\n    for(i in 1:length(genes)){\n        gene<-genes[i]\n        if(peakspergene[gene]==1){\n            rawcounts[gene,allsamples]<-as.numeric(dfanno[dfanno$feature==gene,\n                                                          allsamples])\n        }\n    }\n\n    # Method closest: when multiple peaks are found, keep only the closest to\n    # the TSS as the representative one\n    if(method==\"closest\"){\n        for(i in 1:length(genes)){\n            gene<-genes[i]\n            if(peakspergene[gene]>1){\n                subanno<-dfanno[dfanno$feature==gene,]\n                closest<-which.min(subanno$distanceToStart)\n                # if(any(subanno$distanceToStart<0)){\n                #   stop(\"Stop! Negative distances are not allowed\")\n                # }\n                rawcounts[gene,allsamples]<-as.numeric(\n                    subanno[closest,allsamples])\n            }\n        }\n    }\n\n    # Method farthest: when multiple peaks are found, keep only the closest\n    # to the TSS as the representative one\n    if(method==\"farthest\"){\n        for(i in 1:length(genes)){\n            gene<-genes[i]\n            if(peakspergene[gene]>1){\n                subanno<-dfanno[dfanno$feature==gene,]\n                farthest<-which.max(subanno$distanceToStart)\n                rawcounts[gene,allsamples]<-as.numeric(\n                    subanno[farthest,allsamples])\n            }\n        }\n    }\n\n\n    # Method sum: when multiple peaks are found, keep the strongest as the\n    # representative one\n    if(method==\"sum\"){\n        for(i in 1:length(genes)){\n            gene<-genes[i]\n            if(peakspergene[gene]>1){\n                subanno<-dfanno[dfanno$feature==gene,]\n                sums<-apply(subanno[,allsamples],2,sum)\n                rawcounts[gene,allsamples]<-as.numeric(sums)\n            }\n        }\n    }\n\n    # Method strongest: when multiple peaks are found, keep the strongest as\n    # the representative one\n    if(method==\"strongest\"){\n        for(i in 1:length(genes)){\n            gene<-genes[i]\n            if(peakspergene[gene]>1){\n                subanno<-dfanno[dfanno$feature==gene,]\n                sums<-apply(subanno[,allsamples],1,sum)\n                top<-which.max(sums)\n                rawcounts[gene,allsamples]<-as.numeric(subanno[top,allsamples])\n            }\n        }\n    }\n\n    # Method topvar: when multiple peaks are found, keep the\n    # most varying as the representative one\n    if(method==\"topvar\"){\n        for(i in 1:length(genes)){\n            gene<-genes[i]\n            if(peakspergene[gene]>1){\n                subanno<-dfanno[dfanno$feature==gene,]\n                vars<-apply(subanno[,allsamples],1,var)\n                top<-which.max(vars)\n                rawcounts[gene,allsamples]<-as.numeric(subanno[top,allsamples])\n            }\n        }\n    }\n\n    # Method lowvar: when multiple peaks are found,\n    # keep the least varying as the representative one\n    if(method==\"lowvar\"){\n        for(i in 1:length(genes)){\n            gene<-genes[i]\n            if(peakspergene[gene]>1){\n                subanno<-dfanno[dfanno$feature==gene,]\n                vars<-apply(subanno[,allsamples],1,var)\n                top<-which.min(vars)\n                rawcounts[gene,allsamples]<-as.numeric(subanno[top,allsamples])\n            }\n        }\n    }\n\n    ##### PROCESS RPKMS\n    gr<-GRanges(vobj$peakrpkms)\n    anno<-annotatePeakInBatch(gr,AnnotationData=annotation,output=\"overlapping\",\n                              FeatureLocForDistance=\"TSS\",\n                              bindingRegion=c(lborder,rborder))\n\n    # Convert to a more handy data frame\n    dfanno<-anno\n    names(dfanno)<-1:length(dfanno)\n    dfanno<-as.data.frame(dfanno)\n\n    # Prepare the output table\n    allsamples<-unique(unlist(vobj$samples))\n    genes<-unique(dfanno$feature)\n    peakspergene<-table(dfanno$feature)\n    rpkms<-matrix(NA,nrow=length(genes),ncol=length(allsamples))\n    colnames(rpkms)<-allsamples\n    rownames(rpkms)<-genes\n\n    # All methods: if a gene has a single peak, you select that\n    for(i in 1:length(genes)){\n        gene<-genes[i]\n        if(peakspergene[gene]==1){\n            rpkms[gene,allsamples]<-as.numeric(dfanno[dfanno$feature==gene,\n                                                      allsamples])\n        }\n    }\n\n    # Method closest: when multiple peaks are found, keep only the closest\n    # to the TSS as the representative one\n    if(method==\"closest\"){\n        for(i in 1:length(genes)){\n            gene<-genes[i]\n            if(peakspergene[gene]>1){\n                subanno<-dfanno[dfanno$feature==gene,]\n                closest<-which.min(subanno$distanceToStart)\n                # if(any(subanno$distanceToStart<0)){\n                #   stop(\"Stop! Negative distances are not allowed\")\n                # }\n                rpkms[gene,allsamples]<-as.numeric(subanno[closest,allsamples])\n            }\n        }\n    }\n\n    # Method farthest: when multiple peaks are found, keep only the closest\n    # to the TSS as the representative one\n    if(method==\"farthest\"){\n        for(i in 1:length(genes)){\n            gene<-genes[i]\n            if(peakspergene[gene]>1){\n                subanno<-dfanno[dfanno$feature==gene,]\n                farthest<-which.max(subanno$distanceToStart)\n                rpkms[gene,allsamples]<-as.numeric(subanno[farthest,allsamples])\n            }\n        }\n    }\n\n\n    # Method sum: when multiple peaks are found, keep the strongest\n    # as the representative one\n    if(method==\"sum\"){\n        for(i in 1:length(genes)){\n            gene<-genes[i]\n            if(peakspergene[gene]>1){\n                subanno<-dfanno[dfanno$feature==gene,]\n                sums<-apply(subanno[,allsamples],2,sum)\n                rpkms[gene,allsamples]<-as.numeric(sums)\n            }\n        }\n    }\n\n    # Method strongest: when multiple peaks are found, keep the strongest\n    # as the representative one\n    if(method==\"strongest\"){\n        for(i in 1:length(genes)){\n            gene<-genes[i]\n            if(peakspergene[gene]>1){\n                subanno<-dfanno[dfanno$feature==gene,]\n                sums<-apply(subanno[,allsamples],1,sum)\n                top<-which.max(sums)\n                rpkms[gene,allsamples]<-as.numeric(subanno[top,allsamples])\n            }\n        }\n    }\n\n    # Method topvar: when multiple peaks are found, keep the most varying\n    # as the representative one\n    if(method==\"topvar\"){\n        for(i in 1:length(genes)){\n            gene<-genes[i]\n            if(peakspergene[gene]>1){\n                subanno<-dfanno[dfanno$feature==gene,]\n                vars<-apply(subanno[,allsamples],1,var)\n                top<-which.max(vars)\n                rpkms[gene,allsamples]<-as.numeric(subanno[top,allsamples])\n            }\n        }\n    }\n\n    # Method lowvar: when multiple peaks are found, keep the least varying\n    # as the representative one\n    if(method==\"lowvar\"){\n        for(i in 1:length(genes)){\n            gene<-genes[i]\n            if(peakspergene[gene]>1){\n                subanno<-dfanno[dfanno$feature==gene,]\n                vars<-apply(subanno[,allsamples],1,var)\n                top<-which.min(vars)\n                rpkms[gene,allsamples]<-as.numeric(subanno[top,allsamples])\n            }\n        }\n    }\n\n    ### Fix data types as needed\n    for(j in 1:ncol(rawcounts)){\n        rawcounts[,j]<-as.numeric(rawcounts[,j])\n    }\n    rawcounts<-as.matrix(rawcounts)\n\n    for(j in 1:ncol(rpkms)){\n        rpkms[,j]<-as.numeric(rpkms[,j])\n    }\n    rpkms<-as.matrix(rpkms)\n\n    # Return object\n    vobj$rawcounts<-rawcounts\n    vobj$rpkms<-rpkms\n    return(vobj)\n}\n\n\n\n# vulcan.signature<-function(vobj,contrast=1){\n#   anno<-vobj[[contrast]]\n#   ## As signature we use -log10(sign(fold)*p)\n#   # Fold change is not recapitulating the replicate agreements\n#   signature<-anno$p.value*sign(anno$Fold)\n#   names(signature)<-anno$feature\n#   # Uniform ultrasmall gaussian noise (if by chance no reflist genes get\n#   # into the null GSEA function, we get a division by zero)\n#   set.seed(1)\n#   othergenes<-setdiff(allgenes,names(signature))\n# gaussiannoise<-setNames(rnorm(length(othergenes),\n#                               mean=0,sd=0.01),othergenes) # very small\n#   signature<-c(signature,gaussiannoise)\n# }\n\n\n\n#' Function to normalize promoter peak data\n#'\n#' This function normalizes gene-centered ChIP-Seq data using VST\n#'\n#' @param vobj a list, the output of the \\code{\"vulcan.annotate\"} function\n#'\n#' @return a list\n#'\n#' @examples\n#' require(vulcandata)\n#' vfile<-\"deleteme.csv\"\n#' vulcansheet(vfile)\n#' vobj<-vulcan.import(vfile)\n#' unlink(vfile)\n#' vobj<-vulcan.annotate(vobj,lborder=-10000,rborder=10000,method=\"sum\")\n#' vobj<-vulcan.normalize(vobj)\n#' @export\nvulcan.normalize<-function(vobj){\n    # Extract raw counts from object\n    samples<-vobj$samples\n    rawcounts<-vobj$rawcounts\n    allsamples<-unique(unlist(samples))\n    allgenes<-rownames(rawcounts)\n\n    # Generate a normalized abundance object\n    conditions<-c()\n    for(i in 1:length(samples)){\n        conditions<-c(conditions,rep(names(samples)[i],length(samples[[i]])))\n    }\n    conditions<-factor(conditions)\n    cds<-newCountDataSet(vobj$rawcounts,conditions)\n    cds<-estimateSizeFactors(cds)\n    cds<-estimateDispersions(cds,fitType=\"local\")\n    vsd<-varianceStabilizingTransformation(cds)\n    normalized<-exprs(vsd)\n    rownames(normalized)<-rownames(rawcounts)\n    vobj$normalized<-normalized\n    return(vobj)\n}\n\n#' VULCAN - VirtUaL Chipseq data Analysis using Networks\n#'\n#' This function calculates the enrichment of a gene regulatory network over a\n#' ChIP-Seq derived signature\n#'\n#' @param vobj a list, the output of the \\code{\"vulcan.normalize\"} function\n#' @param network an object of class \\code{\"viper::regulon\"}\n#' @param contrast a vector of two fields, containing the condition names\n#' to be compared (1 vs 2)\n#' @param annotation an optional named vector to convert gene identifiers\n#' (e.g. entrez ids to gene symbols)\n#' Default (NULL) won't convert gene names.\n#'\n#' @return a list\n#'\n#' @examples\n#' require(vulcandata)\n#' # Generate an annotation file from the dummy ChIP-Seq dataset\n#' vfile<-\"deleteme.csv\"\n#' vulcansheet(vfile)\n#' # Import BAM and BED information into a list object\n#' vobj<-vulcan.import(vfile)\n#' unlink(vfile)\n#' # Annotate peaks to gene names\n#' vobj<-vulcan.annotate(vobj,lborder=-10000,rborder=10000,method=\"sum\")\n#' # Normalize data for VULCAN analysis\n#' vobj<-vulcan.normalize(vobj)\n#' # Detect which conditions are present\n#' names(vobj$samples)\n#'\n#' # Load an ARACNe network\n#' # This is a regulon object as specified in the VIPER package, named \"network\"\n#' load(system.file(\"extdata\",\"network.rda\",package=\"vulcan\",mustWork=TRUE))\n#' # Run VULCAN\n#' # We can reduce the minimum regulon size, since in this example only one\n#' # chromosome\n#' # was measured, and the networks would otherwise have too few hits\n#' vobj_analysis<-vulcan(vobj,network=network,contrast=c(\"t90\",\"t0\"),minsize=5)\n#' # Visualize output using the msviper plotting function\n#' plot(vobj_analysis$msviper,mrs=7)\n#'\n#' @export\nvulcan<-function(vobj,network,contrast,annotation=NULL,minsize=10){\n    tfs<-names(network)\n    samples<-vobj$samples\n    normalized<-vobj$normalized\n\n    # Prepare output objects\n    msvipers<-matrix(NA,ncol=3,nrow=length(tfs))\n    rownames(msvipers)<-tfs\n    # Define contrast\n    a<-samples[[contrast[1]]]\n    b<-samples[[contrast[2]]]\n    # Vulcan msviper implementation\n    set.seed(1)\n    signature<-rowTtest(normalized[,a],normalized[,b])$statistic\n    dnull<-ttestNull(normalized[,a],normalized[,b],per=1000)\n    msviper<-msviper(signature,network,dnull,minsize=minsize)\n    # Annotate\n    if(!is.null(annotation)){\n        msviper<-msviperAnnot(msviper,annotation)\n    }\n    vobj$msviper<-msviper\n    # Specific Master Regulators\n    mrs<-cbind(msviper$es$nes,z2p(msviper$es$nes))\n    colnames(mrs)<-c(\"NES\",\"pvalue\")\n    vobj$mrs<-mrs\n\n    return(vobj)\n}\n\n\nvulcan.pathways<-function(vobj,pathways,contrast=NULL,method=c(\"GSEA\",\"REA\")){\n    normalized<-vobj$normalized\n    samples<-vobj$samples\n    allgenes<-unique(unlist(pathways))\n\n    # Specific contrast\n    if(!setequal(contrast,\"all\")){\n        # Define contrast\n        a<-samples[[contrast[1]]]\n        b<-samples[[contrast[2]]]\n\n        # Prepare signature\n        set.seed(1)\n        signature<-rowTtest(normalized[,a],normalized[,b])$statistic\n        othergenes<-setdiff(allgenes,names(signature))\n        gaussiannoise<-setNames(rnorm(length(othergenes),mean=0,sd=0.01),\n                                othergenes) # very small\n        signature<-c(signature,gaussiannoise)\n\n        # GSEA\n        if(method==\"GSEA\"){\n            gsea.pathways<-setNames(rep(0,length(pathways)),names(pathways))\n            message(\"Running GSEA for \",length(pathways),\" pathways\")\n            pb<-txtProgressBar(0,length(pathways),style=3)\n            i<-0\n            for(pname in names(pathways)){\n                p<-pathways[[pname]]\n                obj<-gsea(reflist=signature,set=p,method=\"pareto\",np=100)\n                gsea.pathways[pname]<-obj$nes\n                setTxtProgressBar(pb,i<-i+1)\n            }\n            return(gsea.pathways)\n        }\n\n        # REA\n        if(method==\"REA\"){\n            rea.pathways<-setNames(rep(0,length(pathways)),names(pathways))\n            message(\"Running REA for \",length(pathways),\" pathways\")\n            rea.pathways<-rea(signatures=signature,groups=pathways,minsize=1)\n            return(rea.pathways)\n        }\n    } else {\n        if(method!=\"REA\"){\n            stop(\"Multiple signatures supported only with method='REA'\")\n        }\n        signatures<-t(scale(t(vobj$normalized)))\n        rea.pathways<-rea(signatures=signatures,groups=pathways,minsize=1)\n        return(rea.pathways)\n    }\n\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n",
    "created" : 1495807652936.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1335169604",
    "id" : "1786B715",
    "lastKnownWriteTime" : 1495807715,
    "last_content_update" : 1495807715974,
    "path" : "~/Dropbox/rstudio/vulcanpackage/vulcan/R/vulcan.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}